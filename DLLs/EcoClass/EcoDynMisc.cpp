/**
 * Filename: EcoDynMisc.cpp
 * Copyright: P.Duarte & A.Pereira
 * Author: Ant?nio Pereira
 * Description: Base Class - miscellaneous methods to save/restore model files
 * Date: 28-06-2003
 */

/**
 * NPI work
 * 	02 October 2013, AP :: inclusion of __GNUC__ or __BORLANDC__ symbols
 */

#ifdef __BORLANDC__
	#include <math.h>
	#include <time.h>

	#ifdef _PORT_FORTRAN_
		#include <strings.h>
	#else
		#include "iodll.h"
	#endif //_PORT_FORTRAN_
	
#else	// __BORLANDC__
	#include <cmath>
	#include <ctime>
	#include <cstdio>
	
	using namespace std;
	#include "iodll.h"
#endif	// __BORLANDC__
#include "EcoDynClass.h"

//---------------------------------------------------------------------------

void TEcoDynClass::randomize()
{
    srand(time(NULL));
}
//---------------------------------------------------------------------------

int TEcoDynClass::random(int maxRand)
{
    return rand() % (maxRand + 1);
}
//---------------------------------------------------------------------------

double TEcoDynClass::random(double maxRand)
{
    double   r;
 
		r = ((double) rand() / RAND_MAX);    // generate a random value between 0 and 1
		r *= maxRand;    // scale this up to the range you want
		return r;
}
//---------------------------------------------------------------------------

void* TEcoDynClass::OpenVariablesFile(char* classPrefix)
{
    return OpenDataFile(classPrefix, GLB_VARIABLES);
}
//---------------------------------------------------------------------------

void* TEcoDynClass::OpenParametersFile(char* classPrefix)
{
    return OpenDataFile(classPrefix, GLB_PARAMETERS);
}
//---------------------------------------------------------------------------

void* TEcoDynClass::OpenDataFile(char* classPrefix, const char* suffix)
{
char FileName[256];

    sprintf(FileName, "%s%s%s%s", MyPEcoDynClass->GetPathName(), PATH_SEPARATOR, classPrefix, suffix);

    TReadWrite* PReadWrite = new TReadWrite(FileName);
    if (PReadWrite->SetupFile(READFILE, true, false))
        return (void*)PReadWrite;
    return NULL;
}
//---------------------------------------------------------------------------

void* TEcoDynClass::SaveVariablesFile(char* classPrefix)
{
    return SaveDataFile(classPrefix, GLB_VARIABLES);
}
//---------------------------------------------------------------------------

void* TEcoDynClass::SaveParametersFile(char* classPrefix)
{
    return SaveDataFile(classPrefix, GLB_PARAMETERS);
}
//---------------------------------------------------------------------------

void* TEcoDynClass::SaveDataFile(char* classPrefix, const char* suffix)
{
char FileName[256], timeMsg[32], header[128];
time_t curTime;
struct tm *timeDT;

    sprintf(FileName, "%s%s%s%s", MyPEcoDynClass->GetPathName(), PATH_SEPARATOR, classPrefix, suffix);

    TReadWrite* PReadWrite = new TReadWrite(FileName);
    if (PReadWrite->SetupFile(WRITENEWFILE, false))
    {
        curTime = time(NULL);
        timeDT = localtime(&curTime);
        strftime(timeMsg, 22, DMY_HMS_FORMAT, timeDT);

        sprintf (header, "File generated by EcoDynamo in %s", timeMsg);
        PReadWrite->WriteCell(header);
        PReadWrite->WriteSeparator(true);
        PReadWrite->WriteSeparator(true);

        return (void*)PReadWrite;
    }
    return NULL;
}
//---------------------------------------------------------------------------

void TEcoDynClass::CloseDataFile(void* fHandle)
{
    delete (TReadWrite*)fHandle;
}
//---------------------------------------------------------------------------

bool TEcoDynClass::SaveMorphology(char* AEcosystemName)
{
    TReadWrite* PReadWrite = (TReadWrite*)SaveDataFile(AEcosystemName, GLB_MORPHOLOGY);
    if (PReadWrite == NULL)
        return false;

    PReadWrite->WriteCell("NumberOfColumns");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell(NumberOfColumns, 0);
    PReadWrite->WriteSeparator(true);

    PReadWrite->WriteCell("NumberOfLines");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell(NumberOfLines, 0);
    PReadWrite->WriteSeparator(true);

    if (NumberOfLayers > 1)
    {
        PReadWrite->WriteCell("NumberOfLayers");
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(NumberOfLayers, 0);
        PReadWrite->WriteSeparator(true);
    }

    PReadWrite->WriteCell("NumberOfBoxes");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell(NumberOfBoxes, 0);
    PReadWrite->WriteSeparator(true);

    PReadWrite->WriteCell("Critical depth for land boundary");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell(ECDCriticalDepthForLandBoundary);
    PReadWrite->WriteSeparator(true);

    PReadWrite->WriteCell("ModelType");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell(modelType);
    PReadWrite->WriteSeparator(true);

    // header
    PReadWrite->WriteCell("Columns");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("Lines");
    PReadWrite->WriteSeparator();
    if (NumberOfLayers > 1)
    {
        PReadWrite->WriteCell("Layers");
        PReadWrite->WriteSeparator();
    }
    PReadWrite->WriteCell("BoxDepth");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("BoxLength");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("BoxWidth");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("BoxElevation");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("BoxType");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("Nboundary");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("Eboundary");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("Sboundary");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("Wboundary");
    PReadWrite->WriteSeparator(true);

    TEcoDynClass* MyTransportPointer = MyPEcoDynClass->GetTransportPointer();
    for (int i = 0; i < NumberOfBoxes; i++)
    {
        int line, column, layer;
        double Depth;

        if (NumberOfLayers == 1)
        {
            line = GetLineNumber(i);
            column = GetColumnNumber(i);
        }
        else {
            line = GetLineNumber3D(i);
            column = GetColumnNumber3D(i);
            layer = GetLayerNumber(i);
        }
        PReadWrite->WriteCell(column, 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(line, 0);
        PReadWrite->WriteSeparator();
        if (NumberOfLayers > 1)
        {
            PReadWrite->WriteCell(layer, 0);
            PReadWrite->WriteSeparator();
        }
        if (MyTransportPointer != NULL)
        {
            MyTransportPointer->Inquiry(GetEcoDynClassName(), Depth,
                                     i,
                                     "Box depth",
                                     ObjectCode);
        }
        else Depth = MyPEcoDynClass->GetBoxDepth(i);
        PReadWrite->WriteCell(Depth, 8);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(MyPEcoDynClass->GetBoxLength(i), 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(MyPEcoDynClass->GetChannelWidth(i), 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(MyPEcoDynClass->GetBoxElevation(i), 8);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(MyPEcoDynClass->GetBoxType(i), 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(MyPEcoDynClass->GetNorthernBoundary(i), 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(MyPEcoDynClass->GetEasternBoundary(i), 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(MyPEcoDynClass->GetSouthernBoundary(i), 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(MyPEcoDynClass->GetWesternBoundary(i), 0);
        PReadWrite->WriteSeparator(true);
    }
    CloseDataFile((void*) PReadWrite);
    return true;
}
//---------------------------------------------------------------------------

bool TEcoDynClass::SaveBenthicSpecies(char* AEcosystemName)
{
    if (!BenthicSpeciesRecordAllocated
            || (NumberOfCellsWithBenthicSpecies <= 0))
        return true;

    TReadWrite* PReadWrite = (TReadWrite*)SaveDataFile(AEcosystemName, GLB_BENTHICSPECIES);
    if (PReadWrite == NULL)
        return false;

    PReadWrite->WriteCell("NumberOfCellsWithBenthicSpecies");
    PReadWrite->WriteSeparator(true);
    PReadWrite->WriteCell(NumberOfCellsWithBenthicSpecies, 0);
    PReadWrite->WriteSeparator(true);
    PReadWrite->WriteSeparator(true);

    PReadWrite->WriteCell("ColumnCoordinate");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("LineCoordinate");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("SpeciesName");
    PReadWrite->WriteSeparator(true);

    for (int j = 0; j < NumberOfCellsWithBenthicSpecies; j++)
    {
        PReadWrite->WriteCell(ABenthicSpeciesRecord[j].ColumnCoordinate + 1, 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(NumberOfLines-ABenthicSpeciesRecord[j].LineCoordinate, 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(ABenthicSpeciesRecord[j].SpeciesName);
        PReadWrite->WriteSeparator(true);
    }
    CloseDataFile((void*) PReadWrite);
    return true;
}
//---------------------------------------------------------------------------

bool TEcoDynClass::SaveLoads(char* AEcosystemName)
{
    int NumberOfMomentsForLoads = NumberOfDaysForLoads + NumberOfHoursForLoads;
// AP, 20090321
//    if (!LoadsExist || (NumberOfLoads <= 0) || (NumberOfMomentsForLoads <= 0))
//        return true;

    TReadWrite* PReadWrite = (TReadWrite*)SaveDataFile(AEcosystemName, GLB_LOADS);
    if (PReadWrite == NULL)
        return false;

    PReadWrite->WriteCell("NumberOfLoads");
    PReadWrite->WriteSeparator();
    if (NumberOfDaysForLoads > 0)
        PReadWrite->WriteCell("NumberOfDaysForLoads");
    else if (NumberOfHoursForLoads > 0)
        PReadWrite->WriteCell("NumberOfHoursForLoads");
    PReadWrite->WriteSeparator(true);

    PReadWrite->WriteCell(NumberOfLoads, 0);
    PReadWrite->WriteSeparator();
    if (NumberOfDaysForLoads > 0)
        PReadWrite->WriteCell(NumberOfDaysForLoads, 0);
    else if (NumberOfHoursForLoads > 0)
        PReadWrite->WriteCell(NumberOfHoursForLoads, 0);
    PReadWrite->WriteSeparator(true);
    PReadWrite->WriteSeparator(true);

    PReadWrite->WriteCell("LoadLines");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("LoadColumns");
    PReadWrite->WriteSeparator();
    if (NumberOfLayers > 0) {
        PReadWrite->WriteCell("LoadLayers");
        PReadWrite->WriteSeparator();
    }
    PReadWrite->WriteCell("LoadName");
    PReadWrite->WriteSeparator(true);

    for (int j = 0; j < NumberOfLoads; j++)
    {
        PReadWrite->WriteCell(NumberOfLines - ALoadRecord[j].LineCoordinate, 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(ALoadRecord[j].ColumnCoordinate + 1, 0);
        PReadWrite->WriteSeparator();
        if (NumberOfLayers > 0) {
            PReadWrite->WriteCell(NumberOfLayers - ALoadRecord[j].LayerCoordinate, 0);
            PReadWrite->WriteSeparator();
        }
        PReadWrite->WriteCell(ALoadRecord[j].LoadName);
        PReadWrite->WriteSeparator(true);
    }
    PReadWrite->WriteSeparator(true);

    for (int j = 0; j < NumberOfLoads; j++)
    {
        char flowStr[8];
        sprintf(flowStr, "Flow%-d", j+1);
        PReadWrite->WriteCell(flowStr);
        PReadWrite->WriteSeparator();
    }
    PReadWrite->WriteSeparator(true);

    for (int Loads = 0; Loads < NumberOfMomentsForLoads; Loads++)
    {
        for (int j = 0; j < NumberOfLoads; j++)
        {
            PReadWrite->WriteCell(ALoadRecord[j].LoadFlow[Loads], 9);
            PReadWrite->WriteSeparator();
        }
        PReadWrite->WriteSeparator(true);
    }
    CloseDataFile((void*) PReadWrite);
    return true;
}
//---------------------------------------------------------------------------

bool TEcoDynClass::SaveLosses(char* AEcosystemName)
{
    int NumberOfMomentsForLosses = NumberOfDaysForLosses + NumberOfHoursForLosses;
// AP, 20090321
//    if (!LossesExist || (NumberOfLosses <= 0) || (NumberOfMomentsForLosses <= 0))
//        return true;

    TReadWrite* PReadWrite = (TReadWrite*)SaveDataFile(AEcosystemName, GLB_LOSSES);
    if (PReadWrite == NULL)
        return false;

    PReadWrite->WriteCell("NumberOfLosses");
    PReadWrite->WriteSeparator();
    if (NumberOfDaysForLosses > 0)
        PReadWrite->WriteCell("NumberOfDaysForLosses");
    else if (NumberOfHoursForLosses > 0)
        PReadWrite->WriteCell("NumberOfHoursForLosses");
    PReadWrite->WriteSeparator(true);

    PReadWrite->WriteCell(NumberOfLosses, 0);
    PReadWrite->WriteSeparator();
    if (NumberOfDaysForLosses > 0)
        PReadWrite->WriteCell(NumberOfDaysForLosses, 0);
    else if (NumberOfHoursForLosses > 0)
        PReadWrite->WriteCell(NumberOfHoursForLosses, 0);
    PReadWrite->WriteSeparator(true);
    PReadWrite->WriteSeparator(true);

    PReadWrite->WriteCell("LossesLines");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("LossesColumns");
    PReadWrite->WriteSeparator();
    if (NumberOfLayers > 0) {
        PReadWrite->WriteCell("LossesLayers");
        PReadWrite->WriteSeparator();
    }
    PReadWrite->WriteCell("LossesName");
    PReadWrite->WriteSeparator(true);

    for (int j = 0; j < NumberOfLosses; j++)
    {
        PReadWrite->WriteCell(NumberOfLines - ALossesRecord[j].LineCoordinate, 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(ALossesRecord[j].ColumnCoordinate + 1, 0);
        PReadWrite->WriteSeparator();
        if (NumberOfLayers > 0) {
            PReadWrite->WriteCell(NumberOfLayers - ALossesRecord[j].LayerCoordinate, 0);
            PReadWrite->WriteSeparator();
        }
        PReadWrite->WriteCell(ALossesRecord[j].LossesName);
        PReadWrite->WriteSeparator(true);
    }
    PReadWrite->WriteSeparator(true);

    for (int j = 0; j < NumberOfLosses; j++)
    {
        char dischStr[8];
        sprintf(dischStr, "Disch%-d", j+1);
        PReadWrite->WriteCell(dischStr);
        PReadWrite->WriteSeparator();
    }
    PReadWrite->WriteSeparator(true);

    for (int Losses = 0; Losses < NumberOfMomentsForLosses; Losses++)
    {
        for (int j = 0; j < NumberOfLosses; j++)
        {
            PReadWrite->WriteCell(ALossesRecord[j].LossFlow[Losses], 9);
            PReadWrite->WriteSeparator();
        }
        PReadWrite->WriteSeparator(true);
    }
    CloseDataFile((void*) PReadWrite);
    return true;
}
//---------------------------------------------------------------------------

bool TEcoDynClass::SaveRivers(char* AEcosystemName)
{
    int NumberOfMomentsForFlowTimeSeries;

    if (!RiversExist || (NumberOfRivers <= 0)
            || ((NumberOfDaysForFlowTimeSeries <= 0) && (NumberOfHoursForFlowTimeSeries <= 0)))
        return true;

    TReadWrite* PReadWrite = (TReadWrite*)SaveDataFile(AEcosystemName, GLB_RIVERS);
    if (PReadWrite == NULL)
        return false;

    PReadWrite->WriteCell("NumberOfRivers");
    PReadWrite->WriteSeparator();
    if (NumberOfDaysForFlowTimeSeries > 0)
    {
        PReadWrite->WriteCell("NumberOfDaysForFlowTimeSeries");
        NumberOfMomentsForFlowTimeSeries = NumberOfDaysForFlowTimeSeries;
    }
    else
    {
        PReadWrite->WriteCell("NumberOfHoursForFlowTimeSeries");
        NumberOfMomentsForFlowTimeSeries = NumberOfHoursForFlowTimeSeries;
    }
    PReadWrite->WriteSeparator(true);
    PReadWrite->WriteCell(NumberOfRivers, 0);
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell(NumberOfMomentsForFlowTimeSeries, 0);
    PReadWrite->WriteSeparator(true);
    PReadWrite->WriteSeparator(true);

    PReadWrite->WriteCell("InputFlowLines");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("InputFlowColumns");
    PReadWrite->WriteSeparator();
    if (NumberOfLayers > 0) {
        PReadWrite->WriteCell("InputFlowLayers");
        PReadWrite->WriteSeparator();
    }
    PReadWrite->WriteCell("Boundary");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("RiverName");
    PReadWrite->WriteSeparator(true);

    for (int j = 0; j < NumberOfRivers; j++)
    {
        PReadWrite->WriteCell(NumberOfLines - ARiverRecord[j].LineCoordinate, 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(ARiverRecord[j].ColumnCoordinate + 1, 0);
        PReadWrite->WriteSeparator();
        if (NumberOfLayers > 0) {
            PReadWrite->WriteCell(NumberOfLayers - ARiverRecord[j].LayerCoordinate, 0);
            PReadWrite->WriteSeparator();
        }
        PReadWrite->WriteCell(ARiverRecord[j].BoundaryNumber, 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(ARiverRecord[j].RiverName);
        PReadWrite->WriteSeparator(true);
    }
    PReadWrite->WriteSeparator(true);

    for (int j = 0; j < NumberOfRivers; j++)
    {
        char flowStr[8];
        sprintf(flowStr, "Flow%-d", j+1);
        PReadWrite->WriteCell(flowStr);
        PReadWrite->WriteSeparator();
    }
    PReadWrite->WriteSeparator(true);

    for (int flows = 0; flows < NumberOfMomentsForFlowTimeSeries; flows++)
    {
        for (int j = 0; j < NumberOfRivers; j++)
        {
            PReadWrite->WriteCell(ARiverRecord[j].RiverFlow[flows], 8);
            PReadWrite->WriteSeparator();
        }
        PReadWrite->WriteSeparator(true);
    }
    CloseDataFile((void*) PReadWrite);
    return true;
}
//---------------------------------------------------------------------------

bool TEcoDynClass::SaveSeaBoundaries(char* AEcosystemName)
{
    int NumberOfMomentsForSeaBoundaries;

    if (!SeaBoundariesExist || (NumberOfSeaBoundaries <= 0)
            || ((NumberOfDaysForSeaBoundaries <= 0) && (NumberOfHoursForSeaBoundaries <= 0)))
        return true;

    TReadWrite* PReadWrite = (TReadWrite*)SaveDataFile(AEcosystemName, GLB_SEABOUNDARIES);
    if (PReadWrite == NULL)
        return false;

    PReadWrite->WriteCell("NumberOfSeaBoundaries");
    PReadWrite->WriteSeparator();
    if (NumberOfDaysForSeaBoundaries > 0)
    {
        PReadWrite->WriteCell("NumberOfDaysForSeaBoundaries");
        NumberOfMomentsForSeaBoundaries = NumberOfDaysForSeaBoundaries;
    }
    else
    {
        PReadWrite->WriteCell("NumberOfHoursForSeaBoundaries");
        NumberOfMomentsForSeaBoundaries = NumberOfHoursForSeaBoundaries;
    }
    PReadWrite->WriteSeparator(true);
    PReadWrite->WriteCell(NumberOfSeaBoundaries, 0);
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell(NumberOfMomentsForSeaBoundaries, 0);
    PReadWrite->WriteSeparator(true);
    PReadWrite->WriteSeparator(true);

    PReadWrite->WriteCell("InputFlowLines");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("InputFlowColumns");
    PReadWrite->WriteSeparator();
    if (NumberOfLayers > 0) {
        PReadWrite->WriteCell("InputFlowLayers");
        PReadWrite->WriteSeparator();
    }
    PReadWrite->WriteCell("Boundary");
    PReadWrite->WriteSeparator(true);

    for (int j = 0; j < NumberOfSeaBoundaries; j++)
    {
        PReadWrite->WriteCell(NumberOfLines - ASeaBoundariesRecord[j].LineCoordinate, 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(ASeaBoundariesRecord[j].ColumnCoordinate + 1, 0);
        PReadWrite->WriteSeparator();
        if (NumberOfLayers > 0) {
            PReadWrite->WriteCell(NumberOfLayers - ASeaBoundariesRecord[j].LayerCoordinate, 0);
            PReadWrite->WriteSeparator();
        }
        PReadWrite->WriteCell(ASeaBoundariesRecord[j].BoundaryNumber, 0);
        PReadWrite->WriteSeparator(true);
    }
    PReadWrite->WriteSeparator(true);

    for (int j = 0; j < NumberOfSeaBoundaries; j++)
    {
        char flowStr[16];
        sprintf(flowStr, "Velocity%-d", j+1);
        PReadWrite->WriteCell(flowStr);
        PReadWrite->WriteSeparator();
    }
    PReadWrite->WriteSeparator(true);

    for (int flows = 0; flows < NumberOfMomentsForSeaBoundaries; flows++)
    {
        for (int j = 0; j < NumberOfSeaBoundaries; j++)
        {
            PReadWrite->WriteCell(ASeaBoundariesRecord[j].Velocity[flows], 8);
            PReadWrite->WriteSeparator();
        }
        PReadWrite->WriteSeparator(true);
    }
    CloseDataFile((void*) PReadWrite);
    return true;
}
//---------------------------------------------------------------------------

bool TEcoDynClass::SaveSediments(char* AEcosystemName)
{
    if (!SedimentsExist || (NumberOfCellsWithSediments <= 0))
        return true;

    TReadWrite* PReadWrite = (TReadWrite*)SaveDataFile(AEcosystemName, GLB_SEDIMENTS);
    if (PReadWrite == NULL)
        return false;

    PReadWrite->WriteCell("NumberOfCellsWithSediments");
    PReadWrite->WriteSeparator(true);
    PReadWrite->WriteCell(NumberOfCellsWithSediments, 0);
    PReadWrite->WriteSeparator(true);
    PReadWrite->WriteSeparator(true);

    PReadWrite->WriteCell("SedimentColumns");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("SedimentLines");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("SedimentName");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("Density");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("Porosity");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("LayerHeight");
    PReadWrite->WriteSeparator();
    PReadWrite->WriteCell("SedimentWaterRatio");
    PReadWrite->WriteSeparator(true);

    for (int j = 0; j < NumberOfCellsWithSediments; j++)
    {
        PReadWrite->WriteCell(ASedimentsRecord[j].ColumnCoordinate + 1, 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(NumberOfLines-ASedimentsRecord[j].LineCoordinate, 0);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(ASedimentsRecord[j].SedimentName);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(ASedimentsRecord[j].Density, 8);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(ASedimentsRecord[j].Porosity, 8);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(ASedimentsRecord[j].LayerHeight, 8);
        PReadWrite->WriteSeparator();
        PReadWrite->WriteCell(ASedimentsRecord[j].SedimentWaterRatio, 8);
        PReadWrite->WriteSeparator(true);
    }
    CloseDataFile((void*) PReadWrite);
    return true;
}
//---------------------------------------------------------------------------

bool TEcoDynClass::SaveTide(char* AEcosystemName)
{
    TEcoDynClass* pTide = GetTidePointer();
    if (pTide == NULL)
        return true;

    TReadWrite* PReadWrite = (TReadWrite*)SaveDataFile(AEcosystemName, GLB_TIDE);
    if (PReadWrite == NULL)
        return false;

    pTide->SaveTide((void*) PReadWrite);
    CloseDataFile((void*) PReadWrite);
    return true;
}
//---------------------------------------------------------------------------


